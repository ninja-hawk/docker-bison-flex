第３回レポート
以下の課題を解き、レポートとしてまとめなさい。



（１）第１、２回目の課題で作成したYacc/Lexプログラムを改良し、VSMコードが生成されるように改良せよ。



（２）コンパイラらしくするため、ファイルからソースコードを読み込み、オブジェクトコードをファイルに出力するように改良せよ。これに伴い、VSMシミュレータの方も改良し、オブジェクトファイルを読み込んでから実行する形に変更せよ。



（３）コンパイラの機能拡張を行う。

　　　拡張として以下が考えられる（何でも良い）。

　　　　・変数が使えるようにする

　　　　・if 文や while 文などの制御文が使えるようにする

　　　など



※参考までにソースファイルを添付する。文字コードは UTF-8 となっている。まずは readme.txt を読むこと。

※添付ソースファイルを利用する場合は、単にそのままコピーするのではなく、自分自身でソースコードを解析し、その結果（理解したこと）をレポートに記載すること。



[課題に関する Q&A ]（随時追加）

Q1:

 (2)に「コンパイラらしく～オブジェクトコードをファイルに出力するように改良せよ。」と書かれているが、オブジェクトコードとはVSMコード(push-iなど)のことか？

A1:

はい、そうです。 
難しい場合は、Moodleに添付している CntrlC.zip のコードを参照して下さい。 



Q2: 

なにを改良してオブジェクトコードをファイルに出力させるのか？

A2:

(1) で作成したコードです。 
授業で紹介したコードを参考にするなら、第10回資料（CalcLコンパイラのYaccプログラムの箇所）を 使うことになるかと思います（＋VSM.hとVSM.c）。このコードでは命令セグメントに生成した機械語を書き出し、VSMシミュレータで命令セグメントに格納された機械語を実行します。 これを命令セグメントではなく、ファイルに出力するように変更します。 
以下のような感じです。 

$ tcc sample.tc　（オブジェクトコードとして sample.toが生成される） 
$ vsm sample.to 

tcc （Tiny C コンパイラ）、vsm（仮想マシン） のように、コンパイラと仮想マシンを別々のコマンドにして下さい。
javac と java のような関係です。 

$ javac HelloWorld.java 
$ java HelloWorld



(1) で最初から上記のように作成すれば、(2) は無しです。 



Q3:

(3) では、どのようなソースプログラムがコンパイルできることを期待しているか?

A3:

Tiny C プログラムのソースプログラム例をMoodleに添付します。

参考にして下さい。



Q4:

授業では今までソースプログラムは標準入力から読み込んでいたが、通常のファイルから読み込むにはどうしたら良いか?

A4:

ファイルポインタ yyin を使用します。

CntrlC.zip に含まれている MainFunc.c の以下のコード片を参考にして下さい。



    if ((yyin=fopen(SourceFile, "r")) == NULL) {         /* オープン */

      fprintf(stderr, "Source file cannot be opened.");

      exit(-1); }                                   /* コンパイル中止 */



Q5:

CntrlC.zip の CソースプログラムをコンパイルするとWarningが出るが、無視しても良いか?

A5:

教科書では、古い言語仕様に基づいたコードが残っているためWarningが出力されます。無視しても大丈夫です。余力があれば、Warningが出ないようにコードを修正して下さい。



Q6:

オブジェクトファイルを仮想マシン（VSMシミュレータ）に読み込ませて実行するにはどうしたら良いか?

A6:

以下のようにすれば実現できます。

1) コンパイラ側：　命令セグメントの内容をバイナリモードでオブジェクトファイルに出力する。

2) 仮想マシン側：　オブジェクトファイルからバイナリモードでデータを読み込み、

　　　　　　　　　それを命令セグメントに格納する。

　　　　　　　　　後はStartVSM で仮想マシンの実行を開始すればOKです。

バイナリファイルの読み書きが不明な場合は、以下を参照して下さい。

https://programming.pc-note.net/c/file5.html



Q7:

CntrlC.zip を展開し Cygwin 上で make コマンドを実行するとエラーとなるが、どのように対処すれば良いか?

A7:

CntrlC.zip の中にはオブジェクトファイル（.o ファイル）が含まれていますが、これを削除した上で再度 make コマンドを実行して下さい。CntrlC.zip に含まれているオブジェクトファイルはmac上のgccでコンパイルし生成されたものです。Windows PC のハードウェア上で動作するオブジェクトファイル（機械語）とは異なります。Cygwin上で動作するオブジェクトファイルに差し替えたCntrlC-cygwin.zipもMoodleに置いています。Cygwinユーザはこちらを使って下さい。




Q8:

CntrlC が mac M1 or M2 上で動作しないが、どのような理由か?

A8:

Q7 と同じ理由です。CntrlC.zip の中にはオブジェクトファイル（.o ファイル）が含まれていますが、これを削除した上で再度 make コマンドを実行して下さい。CntrlC.zip に含まれているオブジェクトファイルはmac x86 上のgccでコンパイルし生成されたものです。M1 / M2 のハードウェア上で動作するオブジェクトファイル（機械語）とは異なります。 


Q9:

以下のようにコンパイラと仮想マシンを分けると確かにスッキリするが、どのようなオブジェクトコード（機械語）が生成されたのかを確認することが出来ない。どのようにすれば良いか？

$ tcc sample.tc　（オブジェクトコードとして sample.toが生成される） 
$ vsm sample.to 


A9:

逆アセンブラ（オブジェクトコードを読み込み、VSMコードをテキストとして表示するツール）を作成してみて下さい。

$ rasm sample.to